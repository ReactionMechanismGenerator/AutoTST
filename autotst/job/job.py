#!/usr/bin/python
# -*- coding: utf-8 -*-

##########################################################################
#
#   AutoTST - Automated Transition State Theory
#
#   Copyright (c) 2015-2020 Richard H. West (r.west@northeastern.edu)
#   and the AutoTST Team
#
#   Permission is hereby granted, free of charge, to any person obtaining a
#   copy of this software and associated documentation files (the 'Software'),
#   to deal in the Software without restriction, including without limitation
#   the rights to use, copy, modify, merge, publish, distribute, sublicense,
#   and/or sell copies of the Software, and to permit persons to whom the
#   Software is furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in
#   all copies or substantial portions of the Software.
#
#   THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#   DEALINGS IN THE SOFTWARE.
#
##########################################################################

import os, time, shutil
import numpy as np
import pandas as pd
import subprocess
import multiprocessing
import logging
FORMAT = "%(filename)s:%(lineno)d %(funcName)s %(levelname)s %(message)s"
logging.basicConfig(format=FORMAT, level=logging.INFO)

from ..calculator.gaussian import Gaussian
from ..calculator.orca import Orca
from ..calculator.vibrational_analysis import VibrationalAnalysis, percent_change
from ..calculator.statmech import StatMech
from ..reaction import Reaction, TS
from ..species import Species, Conformer
from ..geometry import Bond, Angle, Torsion, CisTrans, ChiralCenter
import cclib.io 
import ase
import rmgpy
import rmgpy.molecule



class Job():
    """
    A class to deal with the input and output of calculations
    """

    def __init__(
            self,
            calculator = None, # An AutoTST Gaussian calculator with proper directory settings
            conformer_calculator = None, # an ASE Calculator object to perform the conformer analysis with
            username = None, # the username of the
            partition = None, # The partition to run calculations on
            directory = None, # where to save your files 
            scratch = None, # a directory for temporary files generated by calculators
            exclude = None, # nodes that you wish to exclude
            account = None # the account that you wish to charge for 
            ):

        #assert isinstance(reaction, (Reaction, None)), "Please provide an AutoTST Reaction object"
        self.label = "<AutoTST Job>"

        assert isinstance(exclude, (type(None), str, list)), "Please provide a string or list of string descriptions of the nodes you wish to exclude"
        self.exclude = exclude
        self.account = account
        self.calculator = calculator

        if self.calculator:
            if directory is None:
                logging.info("Job directory not specified...setting Job directory to calculator directory")
                self.directory = self.calculator.directory
            else:
                logging.info("Setting calculator directory to Job directory")
                self.directory = self.calculator.directory = directory
            
            if scratch is None:
                logging.info("Job scratch directory not specified...setting Job scratch to calculator scratch")
                self.scratch = self.calculator.scratch
            else:
                logging.info("Setting calculator scratch to Job scratch")
                self.scratch = self.calculator.scratch = scratch
        else:
            logging.info("No calculator specified")
            if directory is None:
                logging.info("No directory specified...setting directory to .")
                self.directory = '.'
            else:
                self.directory = directory
            if scratch is None:
                logging.info("No scratch directory specified...setting scratch to .")
                self.scratch = '.'
            else:
                self.scratch = scratch
        
        self.conformer_calculator = conformer_calculator
        if self.conformer_calculator:
            self.conformer_calculator.directory = self.scratch
            
        partitions = {}
        if isinstance(partition,str):
            partition = [partition]

        for p in list(partition):
            time = self.get_partition_time(p)
            partitions[p] = time
        self.partition = partitions

        self.username = username


    def __repr__(self):
        return self.label

    def get_partition_time(self,partition):
        command = f"sinfo -p {partition}"
        try:
            with subprocess.Popen(command, shell=True, stdout=subprocess.PIPE) as popen:
                output = popen.communicate()[0]
            time = output.decode().split("\n")[1].split()[2]
        except:
            logging.warning(f"Unable to determine time limit for {partition} partition")
            logging.warning(f"Setting time limit to 24 hr for {partition} partition")
            time = '24:00:00'
        return time #could be infinite

    def build_command(self, autotst_object, ase_calculator):

        nproc = ase_calculator.nprocshared
        self.write_input(autotst_object, ase_calculator)

        label = ase_calculator.label
        scratch = ase_calculator.scratch
        file_path = os.path.join(scratch, label)
        # for testing
        os.environ["FILE_PATH"] = file_path

        command = [
            """sbatch""",
            f"""--job-name="{label}" """,
            f"""--output="{label}.slurm.log" """,
            f"""--error="{label}.slurm.log" """,
            """-N 1""",
            f"""-n {nproc}""",
            f"""-t {self.partition[partition]}""", 
            f"""--mem {ase_calculator.parameters["mem"]}"""
        ]
        # Building on the remaining commands
        if self.partition:
            command.append(f"""-p {self.partition}""")
        if self.exclude:
            if isinstance(self.exclude, str):
                command.append(f"""--exclude={self.exclude}""")
            elif isinstance(self.exclude, list):
                exc = ""
                for e in self.exclude:
                    exc += e
                    exc += ","
                exc = exc[:-1]
                command.append(f"""--exclude={exc}""")
        if self.account:
            command.append(f"""-A {self.account}""")

        command.append(
            f"""--wrap="{self.calculator.command} '{label}.com' > '{label}.log'" """)
        exe = ""
        for c in command:
            # combining the command into a single string, this makes submit go faster.
            exe += c + " "

        return command, label


    def read_log(self, file_path=None):
        """
        A helper method that allows one to easily parse log files
        """
        symbol_dict = {
            35: "Br",
            17: "Cl",
            9:  "F",
            8:  "O",
            7:  "N",
            6:  "C",
            1:  "H",
        }
        atoms = []

        parser = cclib.io.ccread(file_path, loglevel=logging.ERROR)

        for atom_num, coords in zip(parser.atomnos, parser.atomcoords[-1]):
            atoms.append(ase.Atom(symbol=symbol_dict[atom_num], position=coords))

        return ase.Atoms(atoms)

    def write_input(self, conformer, calculator):
        """
        A helper method that will write an input file and move it to the correct scratch directory
        """

        if isinstance(calculator, Orca):
            label = calculator.write_sp_input()
        if isinstance(calculator, ase.calculators.calculator.FileIOCalculator):
            label = calculator.label
            calculator.write_input(conformer.ase_molecule)
            try:
                os.makedirs(calculator.scratch)
            except OSError:
                pass

            shutil.move(
                calculator.label + ".com",
                os.path.join(
                    calculator.scratch,
                    calculator.label + ".com"
                ))

            shutil.move(
                calculator.label + ".ase",
                os.path.join(
                    calculator.scratch,
                    calculator.label + ".ase"
                ))
        
        return label

    def check_complete(self, label):
        """
        A method to determine if a job is still running
        """
        command = f"""squeue -n "{label}" -u "{self.username}" """
        squeue_error = "Socket timed out on send/recv operation"
        squeued = False

        while not squeued:
            with subprocess.Popen(command, shell=True, stdout=subprocess.PIPE) as popen:
                output = popen.communicate()[0]
            if squeue_error in output.decode("utf-8"):
                # squeue is running slowly, waiting a bit and checking again.
                time.sleep(90)
            else:
                squeued = True
        
        if len(output.decode("utf-8").splitlines()) <= 1:
            return True
        else:
            return False

    def submit(self, autotst_object, ase_calculator, restart=False):
        """
        A method to run a slurm sbatch and make sure it isn't stopped by:
        - QOS errors
        - having too many jobs submitted 

        This method,
        - writes an input file
        - builds the command to submit to slurm
        - submits the job to slurm

        Returns ase_calculator.label
        """

        # Write the input file
        self.write_input(autotst_object, ase_calculator)

        # Build the command
        command, label = self.build_command(autotst_object, ase_calculator)

        log_path = os.path.join(ase_calculator.scratch, label + '.log')
        attempted = False

        # Check to see if log file already exists
        if os.path.exists(log_path):
            attempted = True
            if not restart:
                logging.info(
                    "It appears that this job has already been run, not running it a second time.")

        # Check to see if the job is in the queue
        if not self.check_complete(label):
            logging.info(
                f"It appears that {label} is already in the queue...not submitting")
            return label

        # Submit the job
        if restart or not attempted:
            if restart:
                logging.info(
                    f"Restarting calculations for {conformer}."
                )
            sbatch_success = "Submitted batch job"
            squeue_error = "Socket timed out on send/recv operation"
            sbatch_error = "Batch job submission failed: Job violates accounting/QOS policy"
            overall_queue = False # is the overall queue able to accept another job
            user_queue = False # is the user's queue able to accept another job
            submitted = False # has the job been submitted yet?

            # to check the number of jobs in the whole queue
            while not overall_queue:
                # while the overall queue is big and there are fewer than 10 attempts to squeue
                with subprocess.Popen("squeue", shell=True, stdout=subprocess.PIPE) as popen:
                    squeue_output = popen.communicate()[0]
                if squeue_error in squeue_output.decode("utf-8"):
                    # squeue is having a slow response time, waiting and trying again
                    logging.error("There is a slow response time for squeue, waiting and trying again")
                    time.sleep(90)
                elif len(squeue_output.decode("utf-8").splitlines()) > 10000: 
                    #greater than 10k jobs, the limit for discovery, waiting and trying again
                    logging.error("There are too many jobs in the queue at the moment, trying to submit in a bit")
                    time.sleep(90)
                else:
                    logging.info("The overall queue is okay to submit a job.")
                    overall_queue = True
                    
            try:
                os.environ["TEST_STATUS"]
                time.wait(90)
                # Adding this for testing
            except:
                pass

            # to check the number of jobs that the user has in the queue
            while not user_queue:
                with subprocess.Popen(f"squeue -u {self.username}", shell=True, stdout=subprocess.PIPE) as popen:
                    squeue_output = popen.communicate()[0]
                if squeue_error in squeue_output.decode("utf-8"):
                    # squeue is having a slow response time, waiting and trying again
                    logging.error("There is a slow response time for squeue, waiting and trying again")
                    time.sleep(90)
                elif len(squeue_output.decode("utf-8").splitlines()) > 500: 
                    # user has greater than than 500 jobs, the limit for discovery is 1.5k, waiting and trying again
                    logging.error("The user has too many jobs in the queue at the moment, trying to submit in a bit")
                    time.sleep(90)
                else:
                    logging.info("The user's queue is okay to submit a job.")
                    user_queue = True

            del squeue_output # we don't need this anymore
            while not submitted: 
                # It's not submitted or there are fewer than 10 attempts to sbatch
                with subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, cwd=ase_calculator.scratch) as popen:
                    sbatch_output = popen.communicate()[0]
                time.sleep(10)
                if not self.check_complete(label):
                    logging.info(
                        f"Job {label} submitted via sbatch.")
                    submitted = True
                    return label

                if sbatch_error in sbatch_output.decode("utf-8"):
                    # we ran into a QOS / accounting error, this occured because jobs were submitted between now and when we last checked the queue.
                    # gonna wait and try again
                    logging.error("Ran into an issue when trying to submit a job, waiting a bit and trying it in a bit")
                    time.sleep(90)
                else:
                    logging.info("Job submitted via sbatch.")
                    submitted = True
        
        return label
